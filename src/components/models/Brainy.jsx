/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'

export function Brainy(props) {
  const { nodes, materials } = useGLTF('/models/brain.glb')
  const meshRef = useRef()
  const wireframeRef = useRef()
  
  // Original texture from the model
  const originalTexture = materials.HumanBrain_Texture.map
  
  // Create shader material for neural activity
  const neuralShaderMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        baseTexture: { value: originalTexture },
        color1: { value: new THREE.Color('#4086f4') }, // Blue electric color
        color2: { value: new THREE.Color('#00ffff') }, // Cyan for contrast
        pulseIntensity: { value: 0.8 }, // Intensity of the neural pulse effect
        glowIntensity: { value: 0.7 }, // Intensity of the glow effect
        mousePosition: { value: new THREE.Vector2(0, 0) }, // Mouse position for interactive effects
        wireframeThickness: { value: 0.03 }, // Control wireframe line thickness
        noiseScale: { value: 5.0 }, // Scale of the noise pattern
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform sampler2D baseTexture;
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float pulseIntensity;
        uniform float glowIntensity;
        uniform vec2 mousePosition;
        uniform float wireframeThickness;
        uniform float noiseScale;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        // Improved noise function
        float hash(float n) {
          return fract(sin(n) * 43758.5453123);
        }
        
        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          
          float a = hash(i.x + i.y * 57.0);
          float b = hash(i.x + 1.0 + i.y * 57.0);
          float c = hash(i.x + i.y * 57.0 + 1.0);
          float d = hash(i.x + 1.0 + i.y * 57.0 + 1.0);
          
          vec2 u = f * f * (3.0 - 2.0 * f);
          
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        
        // FBM (Fractal Brownian Motion)
        float fbm(vec2 p) {
          float value = 0.0;
          float amplitude = 0.5;
          float frequency = noiseScale;
          
          for (int i = 0; i < 5; i++) {
            value += amplitude * noise(p * frequency);
            amplitude *= 0.5;
            frequency *= 2.0;
          }
          
          return value;
        }
        
        // Advanced edge detection for wireframe effect
        float getWireframe() {
          // Using derivatives for precise edge detection
          vec3 ddx = dFdx(vPosition);
          vec3 ddy = dFdy(vPosition);
          vec3 xnormal = normalize(cross(ddx, ddy));
          
          // Calculate grid-based wireframe
          vec2 grid = abs(fract(vUv * 20.0) - 0.5) / fwidth(vUv * 20.0);
          float gridFactor = min(grid.x, grid.y);
          
          // Calculate curvature-based wireframe
          float curvature = abs(dot(xnormal, vNormal));
          float curvatureWire = 1.0 - smoothstep(0.0, 0.5, curvature);
          
          // Combine both wireframe techniques
          float wireIntensity = smoothstep(wireframeThickness, 0.0, min(gridFactor, 1.0 - curvatureWire));
          
          return wireIntensity;
        }
        
        // Electric pulse function that follows wireframe edges
        float getElectricPulse(float wireframe, vec2 uv) {
          float t = time * 0.8;
          
          // Create multiple moving pulse waves along the wireframe
          float wave1 = sin(uv.x * 8.0 + uv.y * 6.0 + t * 3.0) * 0.5 + 0.5;
          float wave2 = cos(uv.x * 6.0 - uv.y * 8.0 - t * 2.0) * 0.5 + 0.5;
          float wave3 = sin(uv.x * 4.0 + uv.y * 7.0 + t * 4.0) * 0.5 + 0.5;
          
          // Combine waves and make them follow the wireframe
          float combinedWave = max(max(wave1, wave2), wave3);
          
          // Make pulses move along the wireframe
          float pulseAlongWire = combinedWave * wireframe;
          
          // Add electric nodes at intersections
          vec2 nodePos1 = vec2(0.3 + sin(t * 0.2) * 0.2, 0.7 + cos(t * 0.3) * 0.2);
          vec2 nodePos2 = vec2(0.7 + cos(t * 0.4) * 0.2, 0.3 + sin(t * 0.5) * 0.2);
          vec2 nodePos3 = vec2(0.5 + sin(t * 0.6) * 0.3, 0.5 + cos(t * 0.7) * 0.3);
          
          float node1 = smoothstep(0.05, 0.0, length(uv - nodePos1));
          float node2 = smoothstep(0.05, 0.0, length(uv - nodePos2));
          float node3 = smoothstep(0.05, 0.0, length(uv - nodePos3));
          
          float nodes = max(max(node1, node2), node3);
          
          // Create dynamic electric paths between nodes
          float path1 = smoothstep(0.03, 0.0, abs(length(uv - nodePos1) + length(uv - nodePos2) - length(nodePos1 - nodePos2)));
          float path2 = smoothstep(0.03, 0.0, abs(length(uv - nodePos2) + length(uv - nodePos3) - length(nodePos2 - nodePos3)));
          float path3 = smoothstep(0.03, 0.0, abs(length(uv - nodePos3) + length(uv - nodePos1) - length(nodePos3 - nodePos1)));
          
          // Add FBM noise to make the electric effect more natural
          float noiseFactor = fbm(uv * 10.0 + t * 0.1);
          
          // Combine everything into a final electric effect
          float electricEffect = pulseAlongWire;
          electricEffect = max(electricEffect, (path1 + path2 + path3) * (0.5 + 0.5 * sin(t * 10.0)));
          electricEffect = max(electricEffect, nodes * (0.8 + 0.2 * sin(t * 15.0)));
          
          // Add noise variation
          electricEffect *= (0.8 + 0.2 * noiseFactor);
          
          return electricEffect * pulseIntensity;
        }
        
        void main() {
          // Base texture color
          vec4 baseColor = texture2D(baseTexture, vUv);
          
          // Get wireframe pattern
          float wireframe = getWireframe();
          
          // Get electric pulse effect along wireframe
          float electricPulse = getElectricPulse(wireframe, vUv);
          
          // Apply distance-based effect from mouse position
          vec2 normalizedMousePos = mousePosition * 0.5 + 0.5; // Convert from -1,1 to 0,1
          float mouseDistance = length(vUv - normalizedMousePos);
          float mouseEffect = smoothstep(0.5, 0.0, mouseDistance);
          
          // Create dynamic color based on time and position
          vec3 pulseColor = mix(color1, color2, sin(time * 1.5 + vUv.x * 3.0) * 0.5 + 0.5);
          
          // Create glowing wireframe effect
          float wireGlow = smoothstep(wireframeThickness * 2.0, 0.0, min(1.0, wireframe)) * glowIntensity;
          
          // Final color combines base texture with wireframe and electric effects
          vec3 finalColor = baseColor.rgb * 0.4; // Dim base color
          
          // Add dark wireframe base
          finalColor = mix(finalColor, vec3(0.05, 0.05, 0.1), wireframe * 0.7);
          
          // Add electric pulse effect
          finalColor = mix(finalColor, pulseColor, electricPulse);
          
          // Add glow effect
          finalColor += pulseColor * wireGlow * 0.5;
          
          // Add mouse interaction effect
          finalColor += pulseColor * mouseEffect * 0.3 * (0.5 + 0.5 * sin(time * 5.0));
          
          // Add slight variation based on normal for depth
          finalColor += pulseColor * 0.1 * max(0.0, dot(vNormal, normalize(vec3(1.0, 1.0, 1.0))));
          
          gl_FragColor = vec4(finalColor, baseColor.a);
        }
      `,
      transparent: true,
      wireframe: false, // We're creating our own wireframe effect in the shader
      side: THREE.DoubleSide, // Render both sides
    });
  }, [originalTexture]);
  
  // Create a wireframe material for the additional wireframe mesh
  const wireframeMaterial = useMemo(() => {
    return new THREE.MeshBasicMaterial({
      color: new THREE.Color('#6ca0ff'), // Light blue color for contrast
      wireframe: true,
      transparent: true,
      opacity: 0.3,
    });
  }, []);
  
  // Update the shader uniforms for animation
  useFrame((state) => {
    if (meshRef.current) {
      // Update time for animation
      meshRef.current.material.uniforms.time.value = state.clock.elapsedTime;
      
      // Mouse position affects neural activity intensity
      const mouseX = state.mouse.x; // -1 to 1
      const mouseY = state.mouse.y; // -1 to 1
      
      // Update mouse position uniform
      meshRef.current.material.uniforms.mousePosition.value.set(mouseX, mouseY);
      
      // Calculate distance from mouse to center (0,0)
      const mouseDistFromCenter = Math.sqrt(mouseX * mouseX + mouseY * mouseY);
      
      // Adjust pulse intensity based on mouse movement
      // Mouse movement increases neural activity
      const basePulseIntensity = 0.8;
      const pulseIntensityVariation = 0.4;
      meshRef.current.material.uniforms.pulseIntensity.value = 
        basePulseIntensity + pulseIntensityVariation * mouseDistFromCenter;
      
      // Adjust noise scale based on mouse Y position for more dynamic effects
      meshRef.current.material.uniforms.noiseScale.value = 
        5.0 + mouseY * 3.0;
      
      // Adjust wireframe thickness based on time for pulsing effect
      meshRef.current.material.uniforms.wireframeThickness.value = 
        0.03 + Math.sin(state.clock.elapsedTime * 0.8) * 0.01;
      
      // Adjust glow intensity based on time for a breathing effect
      const baseGlowIntensity = 0.7;
      const glowIntensityVariation = 0.3;
      meshRef.current.material.uniforms.glowIntensity.value = 
        baseGlowIntensity + Math.sin(state.clock.elapsedTime * 0.5) * glowIntensityVariation;
      
      // Add subtle rotation to the brain based on mouse position
      meshRef.current.rotation.y = -Math.PI/2 + mouseX * 0.1;
      meshRef.current.rotation.x = mouseY * 0.1;
      
      // Sync wireframe mesh with the main mesh
      if (wireframeRef.current) {
        wireframeRef.current.rotation.copy(meshRef.current.rotation);
      }
    }
  });
  return (
    <group {...props}>
      {/* Main brain mesh with neural shader */}
      <mesh
        ref={meshRef}
        castShadow
        receiveShadow
        geometry={nodes.Stylized_Human_Brain.geometry}
        material={neuralShaderMaterial}
        position={[0, -0.05, 0]} 
        rotation={[0, -Math.PI/2, 0]}
        scale={1.8}
      />
      
      {/* Additional wireframe mesh to enhance the electric effect */}
      <mesh
        ref={wireframeRef}
        castShadow
        receiveShadow
        geometry={nodes.Stylized_Human_Brain.geometry}
        material={wireframeMaterial}
        position={[0, -0.05, 0]} 
        rotation={[0, -Math.PI/2, 0]} 
        scale={1.801} // Slightly larger to prevent z-fighting
      />
    </group>
  )
}

useGLTF.preload('/models/brain.glb')
