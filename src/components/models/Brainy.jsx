/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useMemo } from 'react'
import { useGLTF, useTexture, Clone } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'

// Custom vertex shader for extrusion effect
const vertexShader = `
  uniform float time;
  uniform vec3 mousePosition;
  varying vec3 vPosition;
  varying float vDistance;

  void main() {
    vPosition = position;
    
    // Calculate distance to mouse position in world space
    vec4 worldPos = modelMatrix * vec4(position, 1.0);
    float dist = distance(worldPos.xyz, mousePosition);
    vDistance = dist;    // Calculate extrusion amount based on distance
    float maxDist = 0.5;
    float extrudeAmount = smoothstep(maxDist, 0.0, dist) * 0.015;
    
    // Extrude along normal without wave effect
    vec3 newPosition = position + normal * extrudeAmount;
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  }
`

const fragmentShader = `
  uniform float time;
  varying vec3 vPosition;
  varying float vDistance;

  void main() {
    // Base color (transparent blue)
    vec3 baseColor = vec3(0.25, 0.52, 0.95);
    
    // Highlight color (bright cyan)
    vec3 highlightColor = vec3(0.0, 1.0, 1.0);    // Mix colors based on distance
    float maxDist = 0.2;
    float colorMix = smoothstep(maxDist, 0.0, vDistance);
    
    vec3 finalColor = mix(baseColor, highlightColor, colorMix);
    
    // Opacity transition (more transparent when far)
    float opacity = mix(0.05, 0.3, colorMix);
    
    gl_FragColor = vec4(finalColor, opacity);
  }
`

export function Brainy(props) {
  const group = useRef()
  const { scene } = useGLTF('/models/brain.glb')
  const mousePosition = useRef(new THREE.Vector3())
  const raycaster = useRef(new THREE.Raycaster())
  const gradientMap = useTexture('/gradients/5.jpg')
  
  // Create materials
  const toonMaterial = useMemo(() => {
    // Configure texture for toon shading
    gradientMap.minFilter = THREE.NearestFilter
    gradientMap.magFilter = THREE.NearestFilter
    gradientMap.generateMipmaps = false
    
    return new THREE.MeshToonMaterial({
      color: new THREE.Color('#4086f4'), // Base blue color
      gradientMap: gradientMap,
      emissive: new THREE.Color('#00ffff'), // Subtle cyan glow
      emissiveIntensity: 0.2,
    })
  }, [gradientMap])
  
  const wireframeMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        time: { value: 0 },
        mousePosition: { value: new THREE.Vector3(0, 0, 100) }
      },
      transparent: true,
      wireframe: true,
    })
  }, [])
  
  // Create clones with different materials
  const toonBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = toonMaterial
      }
    })
    return clonedScene
  }, [scene, toonMaterial])
  
  const wireframeBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = wireframeMaterial
        child.position.set(0, -0.021, 0) // Reset position to avoid offset
        child.scale.set(2.01, 2.01, 2.01) // Slightly larger to prevent z-fighting
      }
    })
    return clonedScene
  }, [scene, wireframeMaterial])
  
  // Animation and interaction
  useFrame((state) => {
    if (group.current) {
      // Mouse-based rotation
      const mouseX = state.mouse.x * 0.1
      const mouseY = state.mouse.y * 0.1
      
      group.current.rotation.y = -Math.PI/2 + mouseX
      group.current.rotation.x = mouseY
      
      // Update mouse position for shader
      raycaster.current.setFromCamera(state.mouse, state.camera)
      const intersects = raycaster.current.intersectObject(group.current, true)
      
      if (intersects.length > 0) {
        mousePosition.current.copy(intersects[0].point)
      }      // Update shader uniforms
      const t = state.clock.getElapsedTime()
      wireframeMaterial.uniforms.time.value = t
      
      // Update mouse position with fallback
      if (intersects.length > 0) {
        mousePosition.current.copy(intersects[0].point)
      } else {
        // Move mouse position far away when not hovering
        mousePosition.current.set(1000, 1000, 1000)
      }
      wireframeMaterial.uniforms.mousePosition.value.copy(mousePosition.current)
      
      // Toon material animation
      const pulse = Math.sin(t * 0.5) * 0.1 + 0.9
      toonMaterial.color.setRGB(0.25 + 0.1 * pulse, 0.4 + 0.1 * pulse, 0.96)
      toonMaterial.emissiveIntensity = 0.1 + Math.sin(t * 0.7) * 0.1
    }
  })
  
  return (
    <group {...props}>
      <group ref={group}>        {/* Original model with toon material */}
        <Clone object={toonBrain} />
        
        {/* Wireframe overlay */}
        <Clone object={wireframeBrain} />
      </group>
    </group>
  )
}

useGLTF.preload('/models/brain.glb')
