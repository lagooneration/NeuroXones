/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useMemo } from 'react'
import { useGLTF, useTexture, Clone } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'

export function Brainy(props) {
  const group = useRef()
  const { scene, nodes } = useGLTF('/models/brain.glb')
  
  // Load gradient texture for toon shading
  const gradientMap = useTexture('/gradients/5.jpg')
  
  // Create materials
  const toonMaterial = useMemo(() => {
    // Configure texture for toon shading
    gradientMap.minFilter = THREE.NearestFilter
    gradientMap.magFilter = THREE.NearestFilter
    gradientMap.generateMipmaps = false
    
    return new THREE.MeshToonMaterial({
      color: new THREE.Color('#4086f4'), // Base blue color
      gradientMap: gradientMap,
      emissive: new THREE.Color('#00ffff'), // Subtle cyan glow
      emissiveIntensity: 0.2,
    })
  }, [gradientMap])
  
  const wireframeMaterial = useMemo(() => {
    return new THREE.MeshBasicMaterial({
      color: new THREE.Color('#4086f4'), // Electric blue
      wireframe: true,
      transparent: true,
      opacity: 0.1,
    })
  }, [])
  
  // Create clones with different materials
  const toonBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = toonMaterial
      }
    })
    return clonedScene
  }, [scene, toonMaterial])
  
  const wireframeBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = wireframeMaterial
        child.position.set(0, -0.021, 0) // Reset position to avoid offset
        child.scale.set(2.01, 2.01, 2.01) // Slightly larger to prevent z-fighting
      }
    })
    return clonedScene
  }, [scene, wireframeMaterial])
  
  // Animation
  useFrame((state) => {
    if (group.current) {
      // Mouse-based rotation
      const mouseX = state.mouse.x * 0.1
      const mouseY = state.mouse.y * 0.1
      
      group.current.rotation.y = -Math.PI/2 + mouseX
      group.current.rotation.x = mouseY
      
      // Animate materials
      const t = state.clock.getElapsedTime()
      
      // Toon material animation
      const pulse = Math.sin(t * 0.5) * 0.1 + 0.9
      toonMaterial.color.setRGB(0.25 + 0.1 * pulse, 0.4 + 0.1 * pulse, 0.96)
      toonMaterial.emissiveIntensity = 0.1 + Math.sin(t * 0.7) * 0.1
      
      // Wireframe animation
      wireframeMaterial.opacity = 0.1 + Math.sin(t) * 0.2
      const hue = (t * 0.05) % 1
      wireframeMaterial.color.setHSL(hue, 0.8, 0.5)
    }
  })
  
  return (
    <group {...props}>
      <group ref={group}>
        {/* Original model with toon material */}
        <primitive object={toonBrain} />
        
        {/* Wireframe overlay */}
        <primitive object={wireframeBrain} />
      </group>
    </group>
  )
}

useGLTF.preload('/models/brain.glb')
