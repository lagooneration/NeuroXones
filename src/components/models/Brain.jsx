/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, useMemo } from 'react'
import { useGLTF, useTexture, Clone } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import PropTypes from 'prop-types'

// Custom vertex shader for extrusion effect with neural activity
const vertexShader = `
  uniform float time;
  uniform vec3 mousePosition;
  varying vec3 vPosition;
  varying float vDistance;
  varying float vNeuralActivity;
  varying vec3 vNormal;
  varying float vParticleEffect;

  void main() {
    vPosition = position;
    vNormal = normal;
    
    // Calculate distance to mouse position in world space
    vec4 worldPos = modelMatrix * vec4(position, 1.0);
    float dist = distance(worldPos.xyz, mousePosition);
    vDistance = dist;
    
    // Smoother extrusion with larger falloff
    float maxDist = 0.7;
    float extrudeAmount = smoothstep(maxDist, 0.0, dist) * 0.01;
    
    
  // Calculate particle flow effect for neurons - only active on hover
    float particleFlow = 0.0;
    if (dist < maxDist * 0.8) { // Increased detection radius
      // Create directional flow effect based on normal direction
      particleFlow = fract(dot(normal, vec3(1.0, 0.5, 0.8)) * 1.5 - time * 2.5); // Adjusted frequency
      // Make sure effect is stronger closer to mouse position
      particleFlow *= smoothstep(maxDist * 0.8, 0.0, dist) * 1.5; // Stronger effect
    }
    vParticleEffect = particleFlow;
    
    // Neural activity now focuses on hover area rather than pulsating everywhere
    vNeuralActivity = smoothstep(maxDist, 0.0, dist);
    
    // Extrude along normal with smoothed effect
    vec3 newPosition = position + normal * extrudeAmount;
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  }
`

const fragmentShader = `
  uniform float time;
  varying vec3 vPosition;
  varying float vDistance;
  varying float vNeuralActivity;
  varying vec3 vNormal;
  varying float vParticleEffect;

  vec3 pulseColor(float t) {
    // Gradient from electric blue to cyan to white
    vec3 color1 = vec3(0.1, 0.4, 0.9);  // Electric blue
    vec3 color2 = vec3(0.0, 1.0, 1.0);  // Cyan
    vec3 color3 = vec3(0.9, 0.95, 1.0); // Almost white
    
    if (t < 0.5) {
      return mix(color1, color2, t * 2.0);
    } else {
      return mix(color2, color3, (t - 0.5) * 2.0);
    }
  }
    // Function to create neuron particle effect
  vec3 neuronParticles(vec3 baseColor, float particleEffect, float distance) {
    // Bright white-blue color for particles - more vibrant
    vec3 particleColor = vec3(1.0, 1.0, 1.0);  // Pure white for more contrast
    
    // Create flowing particle effect - increased detection threshold
    float particleIntensity = step(0.65, particleEffect) * step(distance, 0.25); // Larger radius and more frequent
    
    // Add bright spots for neuron endpoints
    if (particleIntensity > 0.0) {
      // Make particles brighter at certain points for a "flying out" effect - more pronounced transition
      float particleBrightness = smoothstep(0.65, 0.9, particleEffect) * 1.5; // Increased brightness
      return mix(baseColor, particleColor, clamp(particleBrightness, 0.0, 1.0)); // Clamped to avoid oversaturation
    }
    
    return baseColor;
  }

  void main() {
    // Base color (transparent blue)
    vec3 baseColor = vec3(0.25, 0.52, 0.95);
    
    // Distance effect for hover
    float maxDist = 0.3;
    float colorMix = smoothstep(maxDist, 0.0, vDistance);
    
    // Dynamic colors for neural activity effect - only on hover
    vec3 activeColor = pulseColor(vNeuralActivity);
    
    // Create flowing effect along the wireframe on hover
    float flowEffect = smoothstep(0.0, 1.0, sin(vPosition.x * 8.0 + vPosition.y * 6.0 + vPosition.z * 10.0 + time * 3.0) * 0.5 + 0.5);
    flowEffect *= colorMix; // Only flow on hover
    
    // Combine base color with hover-activated color
    vec3 finalColor = mix(baseColor, activeColor, colorMix * flowEffect);
    
    // Add neuron particle effect on hover
    finalColor = neuronParticles(finalColor, vParticleEffect, vDistance);
    
    // Add directional glow based on normal direction for 3D effect
    float normalGlow = abs(dot(normalize(vNormal), vec3(0.0, 1.0, 0.5)));
    finalColor += vec3(0.0, 0.3, 0.6) * normalGlow * colorMix * 0.3;
      // Opacity transition (more visible when active)
    float opacity = mix(0.05, 0.6, colorMix); // Increased maximum opacity
    
    // Brighter particles at endpoints for "flying out" effect - more dramatic
    if (vParticleEffect > 0.7 && vDistance < 0.2) { // Lower threshold, larger area
      // Create more intense "flying" particles
      float particleGlow = pow(vParticleEffect, 2.0) * (1.0 - vDistance * 4.0);
      particleGlow = clamp(particleGlow, 0.0, 1.0);
      
      // Add extra brightness boost for dramatic effect
      finalColor = mix(finalColor, vec3(1.0, 1.0, 1.0), particleGlow * 0.9); // Increased mix factor
      opacity = mix(opacity, 1.0, particleGlow * 0.8); // More visible particles
    }
    
    gl_FragColor = vec4(finalColor, opacity);
  }
`

export function Brain(props) {
  const group = useRef()
  const { scene } = useGLTF('/models/brain.glb', true) // Added draco decoder option
  const mousePosition = useRef(new THREE.Vector3())
  const raycaster = useRef(new THREE.Raycaster())
  const gradientMap = useTexture('/gradients/5.jpg')
  
  // Create materials
  const toonMaterial = useMemo(() => {
    // Configure texture for toon shading
    gradientMap.minFilter = THREE.NearestFilter
    gradientMap.magFilter = THREE.NearestFilter
    gradientMap.generateMipmaps = false
    
    return new THREE.MeshToonMaterial({
      color: new THREE.Color('#4086f4'), // Base blue color
      gradientMap: gradientMap,
      emissive: new THREE.Color('#00ffff'), // Subtle cyan glow
      emissiveIntensity: 0.2,
    })
  }, [gradientMap])
    const wireframeMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        time: { value: 0 },
        mousePosition: { value: new THREE.Vector3(0, 0, 100) }
      },
      transparent: true,
      wireframe: true,
      wireframeLinewidth: 1.5,
    })
  }, [])
  
  // Create clones with different materials
  const toonBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = toonMaterial
      }
    })
    return clonedScene
  }, [scene, toonMaterial])
  
  const wireframeBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = wireframeMaterial
        child.position.set(0, -0.021, 0) // Reset position to avoid offset
        child.scale.set(2.01, 2.01, 2.01) // Slightly larger to prevent z-fighting
      }
    })
    return clonedScene
  }, [scene, wireframeMaterial])
    // Animation and interaction
  useFrame((state) => {
    if (group.current) {
      // Mouse-based rotation
      const mouseX = state.mouse.x * 0.1
      const mouseY = state.mouse.y * 0.1
      
      group.current.rotation.y = -Math.PI/2 + mouseX
      group.current.rotation.x = mouseY
      
      // Update mouse position for shader
      raycaster.current.setFromCamera(state.mouse, state.camera)
      const intersects = raycaster.current.intersectObject(group.current, true)
      
      // Update shader uniforms
      const t = state.clock.getElapsedTime()
      wireframeMaterial.uniforms.time.value = t
      
      // Update mouse position with fallback
      if (intersects.length > 0) {
        mousePosition.current.copy(intersects[0].point)
      } else {
        // Move mouse position further away when not hovering for smoother transition
        mousePosition.current.set(100, 100, 100)
      }
      wireframeMaterial.uniforms.mousePosition.value.copy(mousePosition.current)
      
      // Toon material animation
      const pulse = Math.sin(t * 0.5) * 0.1 + 0.9
      toonMaterial.color.setRGB(0.25 + 0.1 * pulse, 0.4 + 0.1 * pulse, 0.96)
      toonMaterial.emissiveIntensity = 0.1 + Math.sin(t * 0.7) * 0.1
    }
  })
  
  return (
    <group {...props}>
      <group ref={group}>        
        {/* Original model with toon material */}
        <Clone object={toonBrain} />
        
        {/* Wireframe overlay */}
        <Clone object={wireframeBrain} />
      </group>
    </group>  )
}

Brain.propTypes = {
  position: PropTypes.array,
  rotation: PropTypes.array,
  scale: PropTypes.array
}

useGLTF.preload('/models/brain.glb')
