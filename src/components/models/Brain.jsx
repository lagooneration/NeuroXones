/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, useMemo } from 'react'
import { useGLTF, useTexture, Clone } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import PropTypes from 'prop-types'

// Custom vertex shader for extrusion effect with neural activity
const vertexShader = `
  uniform float time;
  uniform vec3 mousePosition;
  varying vec3 vPosition;
  varying float vDistance;
  varying float vNeuralActivity;
  varying vec3 vNormal;

  void main() {
    vPosition = position;
    vNormal = normal;
    
    // Calculate distance to mouse position in world space
    vec4 worldPos = modelMatrix * vec4(position, 1.0);
    float dist = distance(worldPos.xyz, mousePosition);
    vDistance = dist;
    
    // Smoother extrusion with larger falloff
    float maxDist = 0.7;
    float extrudeAmount = smoothstep(maxDist, 0.0, dist) * 0.01;
    
    // Add subtle wave motion to the extrusion
    float wave = sin(position.x * 8.0 + position.y * 8.0 + position.z * 8.0 + time * 3.0) * 0.2;
    extrudeAmount *= (1.0 + wave * smoothstep(maxDist, 0.0, dist));
    
    // Calculate neural activity value for fragment shader
    // This simulates pulses moving along the network
    vNeuralActivity = sin(position.x * 10.0 + position.y * 8.0 + position.z * 6.0 - time * 5.0) * 0.5 + 0.5;
    vNeuralActivity *= smoothstep(maxDist, 0.0, dist) * 0.8 + 0.2;
    
    // Extrude along normal with smoothed effect
    vec3 newPosition = position + normal * extrudeAmount;
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  }
`

const fragmentShader = `
  uniform float time;
  varying vec3 vPosition;
  varying float vDistance;
  varying float vNeuralActivity;
  varying vec3 vNormal;

  vec3 pulseColor(float t) {
    // Gradient from electric blue to cyan to white
    vec3 color1 = vec3(0.1, 0.4, 0.9);  // Electric blue
    vec3 color2 = vec3(0.0, 1.0, 1.0);  // Cyan
    vec3 color3 = vec3(0.9, 0.95, 1.0); // Almost white
    
    if (t < 0.5) {
      return mix(color1, color2, t * 2.0);
    } else {
      return mix(color2, color3, (t - 0.5) * 2.0);
    }
  }

  void main() {
    // Base color (transparent blue)
    vec3 baseColor = vec3(0.25, 0.52, 0.95);
    
    // Dynamic colors for neural activity effect
    vec3 pulseColors = pulseColor(vNeuralActivity);
    
    // Mix colors based on distance and neural activity
    float maxDist = 0.3;
    float colorMix = smoothstep(maxDist, 0.0, vDistance);
    
    // Create moving wave patterns along the wireframe
    float wave = sin(vPosition.x * 15.0 + vPosition.y * 10.0 + vPosition.z * 12.0 - time * 4.0) * 0.5 + 0.5;
    wave *= smoothstep(maxDist, 0.0, vDistance);
    
    // Combine effects for final color
    vec3 finalColor = mix(baseColor, pulseColors, colorMix * (0.7 + 0.3 * wave));
    
    // Add subtle glow for excited neural pathways
    float glowIntensity = smoothstep(0.3, 0.8, vNeuralActivity) * colorMix;
    finalColor += vec3(0.1, 0.5, 0.9) * glowIntensity;
    
    // Opacity transition (more visible when active)
    float opacity = mix(0.05, 0.4, colorMix * (0.8 + 0.2 * vNeuralActivity));
    
    gl_FragColor = vec4(finalColor, opacity);
  }
`

export function Brain(props) {
  const group = useRef()
  const { scene } = useGLTF('/models/brain.glb', true) // Added draco decoder option
  const mousePosition = useRef(new THREE.Vector3())
  const raycaster = useRef(new THREE.Raycaster())
  const gradientMap = useTexture('/gradients/5.jpg')
  
  // Create materials
  const toonMaterial = useMemo(() => {
    // Configure texture for toon shading
    gradientMap.minFilter = THREE.NearestFilter
    gradientMap.magFilter = THREE.NearestFilter
    gradientMap.generateMipmaps = false
    
    return new THREE.MeshToonMaterial({
      color: new THREE.Color('#4086f4'), // Base blue color
      gradientMap: gradientMap,
      emissive: new THREE.Color('#00ffff'), // Subtle cyan glow
      emissiveIntensity: 0.2,
    })
  }, [gradientMap])
    const wireframeMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        time: { value: 0 },
        mousePosition: { value: new THREE.Vector3(0, 0, 100) }
      },
      transparent: true,
      wireframe: true,
      wireframeLinewidth: 1.5,
    })
  }, [])
  
  // Create clones with different materials
  const toonBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = toonMaterial
      }
    })
    return clonedScene
  }, [scene, toonMaterial])
  
  const wireframeBrain = useMemo(() => {
    const clonedScene = scene.clone()
    clonedScene.traverse((child) => {
      if (child.isMesh) {
        child.material = wireframeMaterial
        child.position.set(0, -0.021, 0) // Reset position to avoid offset
        child.scale.set(2.01, 2.01, 2.01) // Slightly larger to prevent z-fighting
      }
    })
    return clonedScene
  }, [scene, wireframeMaterial])
    // Animation and interaction
  useFrame((state) => {
    if (group.current) {
      // Mouse-based rotation
      const mouseX = state.mouse.x * 0.1
      const mouseY = state.mouse.y * 0.1
      
      group.current.rotation.y = -Math.PI/2 + mouseX
      group.current.rotation.x = mouseY
      
      // Update mouse position for shader
      raycaster.current.setFromCamera(state.mouse, state.camera)
      const intersects = raycaster.current.intersectObject(group.current, true)
      
      // Update shader uniforms
      const t = state.clock.getElapsedTime()
      wireframeMaterial.uniforms.time.value = t
      
      // Update mouse position with fallback
      if (intersects.length > 0) {
        mousePosition.current.copy(intersects[0].point)
      } else {
        // Move mouse position further away when not hovering for smoother transition
        mousePosition.current.set(100, 100, 100)
      }
      wireframeMaterial.uniforms.mousePosition.value.copy(mousePosition.current)
      
      // Toon material animation
      const pulse = Math.sin(t * 0.5) * 0.1 + 0.9
      toonMaterial.color.setRGB(0.25 + 0.1 * pulse, 0.4 + 0.1 * pulse, 0.96)
      toonMaterial.emissiveIntensity = 0.1 + Math.sin(t * 0.7) * 0.1
    }
  })
  
  return (
    <group {...props}>
      <group ref={group}>        
        {/* Original model with toon material */}
        <Clone object={toonBrain} />
        
        {/* Wireframe overlay */}
        <Clone object={wireframeBrain} />
      </group>
    </group>  )
}

Brain.propTypes = {
  position: PropTypes.array,
  rotation: PropTypes.array,
  scale: PropTypes.array
}

useGLTF.preload('/models/brain.glb')
